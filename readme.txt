Для имитации задачи был выбран SpringBoot. По REST API приходят запросы,
производится их учёт и сохранение в базу данных postgres. Все действия выполняются
через GET запросы.


WebControllerTimeRecords - это контроллер, который будет создаваться
для каждого из запросов(Scope("request)", это сделано специально,
чтобы была возможность имитировать  многопоточную систему. Каждый новый
запрос, новый scope).

EventRecord - это сущность Entity, которая собственно и представляет сам евент.
То есть там хранится время события и какая-то информация, полученная с ним.

TimeRecord - это сущность, которая создаётся на основе EventRecord,
не имеет в cебе поля data от того будет помещаться в оперативку
в большом количестве.

QueueMaster - отдельный класс, который реализует операции на списке, имеющий
метод очистки от устаревших элементов clear_expired_data. То есть как структура
обычная синхронизированная на все методы очередь,
со специальным методом очистки на устаревшие элементы.

TimeRecordService - собственно производит работу с событиями. Есть внутри 4 очереди.
Также есть внутри buffer, который накапливает элементы. При вызове запроса на размер
он скидывает накопленные элементы (flush), скидываются они в 4 очереди сразу.
Если не происходит запрос на размер, элементы скидываются, когда размер буфера
превышен.

Я решил, что по производительности будет намного быстрее завести 4 очереди.
Предполагая, что запросы на секунду встречаются чаще минуты, минуты встречаются
чаще часа, и запросы про час встречаются чаще дня. Соответственно размер начинает
играть важное значение и нам необходимо чистить их по-разному(слишком долго часто
отвечать на запрос про секунду, шагая по всем элементам дня). Также было предположение,
что запросы на добавления более популярны, чем запрос о количестве событий.

Расход по памяти от 4‑х очередей не превысит 10% при равномерном распределение запросов
по времени.

ScheduleCleaner - bean, который производит очистку очередей на каждый из периодов
времени. Это важно, с учётом сценария, когда много запросов на добавления, наши
очереди могут превысить оперативную память.

-------------

Возможные улучшения

Можно написать "fine_grained locking" за счёт 4 очередей, он у меня реализуется
на очистку. Но на добавления надо много тестировать и я не рискнул.
Также была идея с коллекцией ConcurrentLinkedQueue, но ввиду того, что я хотел
показывать истинное состояние системы, а с этой коллекцией пришлось бы тогда делать
lock и её преимущество бы исчезло.
Очень много зависит от понимания задачи, если есть возможность
откладывать вычисления, то надо делать какие-то подобные подходы(если пару событий
не учтённых не так важны для системы на данный момент времени).